
module sar(clk, en, vinp, vinn, result, vcm, vdd, vss);

///////////////////////////////////
////////// Digital inputs//////////
///////////////////////////////////

input clk; // sar clock input
input en; // sar control signal // en=0 : sample phase. minimum 1 cycle. // en=1 : conversion phase. minimum WIDTH+2 cycles are needed.

input vinp; // sar analog positive input
input vinn; // sar analog negative input (Differential config. : connect negative input / Single-ended config. : connect vcm)

output [`@NBIT-1:0] result; // ADC output

///////////////////////////////////
////////// Analog inputs //////////
///////////////////////////////////

input vcm; // common mode reference input. VDD/2 should be connected
input vdd; // power supply
input vss; // ground

///////////////////////////////////
////////// Internal wires //////////
///////////////////////////////////

wire vcmpp, vcmpn; // cdac output => comparator positive, negative input
wire sample; // input is sampled when sample=1
wire outp, outn; // comparator output
wire comp_clk; // comparator clk

wire [`@NBIT-1:0] value; //CDAC cap control signal

sar_logic isar_logic(
	.clk_sar(clk),
	.en(en),
	.sample(sample),
	.value(value),
	.result_out(result),
	.cmp(outn),
	.cmp_clk(comp_clk),
	.vdd(vdd),
	.vss(vss)
);

cdac icdac(
	.vinp(vinp),
	.vinn(vinn),
	.vrefh(vdd),
	.vrefl(vss),
	.vcmpp(vcmpp),
	.vcmpn(vcmpn),
	.sample(sample),
	.value(value),
	.vdd(vdd),
	.vss(vss)
);

comparator icomparator(
	.clk(comp_clk),
	.vcmpp(vcmpp),
	.vcmpn(vcmpn),
	.outp(outp),
	.outn(outn),
	.vdd(vdd),
	.vss(vss)
);

sh_tg ish_tg_p(
	.vcm(vcm),
	.vcmp(vcmpp),
	.sample(sample),
	.vdd(vdd),
	.vss(vss)
);

sh_tg ish_tg_n(
	.vcm(vcm),
	.vcmp(vcmpn),
	.sample(sample),
	.vdd(vdd),
	.vss(vss)
);


endmodule
